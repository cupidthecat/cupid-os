>comment CupidMark converted document
>h1 CupidC Guide (.cc)
Verified against source on: 2026-02-13
>style bg #F7F4EC
>style body #1A1A1A
>style h1 #B03060
>style h2 #2B4FA8
>style h3 #9A5A00
>style rule #B8B1A3
>style box #EEE7D8
>style boxtext #223355
>style link #1D4ED8
>style linkhover #0B3AA8
>rule

>h2 What Is CupidC
CupidC is the in-OS C-like compiler used for most shell programs in /bin.

Two modes:
1) JIT run:
   cupidc file.cc
2) AOT to ELF:
   ccc file.cc -o output

Shell also auto-discovers and runs:
- /bin/<name>.cc
- /home/bin/<name>.cc
So if a file exists there, you can often just type:
  <name>

>h2 Entry Point
Use:
  void main() { ... }
or:
  int main() { ... return 0; }

>h2 Command-Line Arguments
CupidC programs read args via:
  char *args = get_args();

Example:
  void main() {
    char *args = get_args();
    if (args && args[0]) {
      print("args: ");
      println(args);
    } else {
      println("no args");
    }
  }

>h2 Hello Example
void main() {
  println("Hello from CupidC");
  print("cwd: ");
  println(get_cwd());
}

Save as /home/bin/hello.cc, then run:
  hello

>h2 Language Features (Current)
Supported core features include:
- int, char, void, pointers
- structs (including field access)
- arrays
- if / else
- while / for / do-while
- switch / case / default
- break / continue / return
- function definitions and calls
- typedef and enum support
- basic inline asm blocks
- arithmetic and logical operators

Known practical constraints:
- It is not full GCC C.
- Keep code simple and direct.
- Preprocessor/macros are not a normal workflow.
- One-file program style is the easiest path.

>h2 Useful Bindings (Partial List)
Console:
  print, println, putchar, print_int, print_hex, clear_screen

Memory:
  kmalloc, kfree, memstats, heap_check_integrity, detect_memory_leaks

VFS:
  vfs_open, vfs_read, vfs_write, vfs_seek, vfs_close
  vfs_stat, vfs_readdir, vfs_mkdir, vfs_unlink, vfs_rename
  vfs_read_all, vfs_write_all, vfs_read_text, vfs_write_text, vfs_copy_file

Shell/process:
  get_cwd, set_cwd, resolve_path, get_history_count, get_history_entry
  process_list, process_kill, spawn_test, yield, exit, exec
  get_args

Time/system:
  uptime_ms, get_cpu_mhz, timer_get_frequency
  rtc_hour/minute/second/day/month/year/weekday, rtc_epoch
  date_full_string, time_string, etc.

Debug:
  dump_stack_trace, dump_registers, peek_byte, print_hex_byte
  set_log_level, get_log_level_name, print_log_buffer

Disk/cache:
  blockcache_sync, blockcache_stats

GUI/graphics:
  Large gfx2d and desktop UI binding set is available in GUI mode.

>h2 Fast Workflow
1) Create source:
   ed /home/bin/mycmd.cc

2) Run directly:
   mycmd

3) If needed, run with explicit compiler:
   cupidc /home/bin/mycmd.cc

4) Produce ELF artifact:
   ccc /home/bin/mycmd.cc -o /home/mycmd

>h2 Error Handling Tips
- CupidC fails fast and reports line-oriented compiler errors.
- If behavior is odd, reduce code to a tiny repro and re-add features.
- Keep stack usage modest.
- Prefer kmalloc for large buffers.

>h2 When To Use CupidC Vs ELF C
Use CupidC when:
- You want fastest edit/run loop inside CupidOS shell.
- You want direct access to many kernel helper bindings.

Use ELF C (see 05ELFPROG.TXT) when:
- You want external GCC-based build flow.
- You want a stable syscall-table ABI style entrypoint.

