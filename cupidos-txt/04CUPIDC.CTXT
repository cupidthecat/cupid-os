>comment CupidMark converted document
>h1 CupidC Guide (.cc)
Verified against source on: 2026-02-14
>style bg #F7F4EC
>style body #1A1A1A
>style h1 #B03060
>style h2 #2B4FA8
>style h3 #9A5A00
>style rule #B8B1A3
>style box #EEE7D8
>style boxtext #223355
>style link #1D4ED8
>style linkhover #0B3AA8
>rule

>h2 What Is CupidC
CupidC is the in-OS C-like compiler used for most shell programs in /bin.

Two modes:
1) JIT run:
   cupidc file.cc
2) AOT to ELF:
   ccc file.cc -o output
3) Compile + disassemble (no run):
  cc -d file.cc

Shell also auto-discovers and runs:
- /bin/<name>.cc
- /home/bin/<name>.cc
So if a file exists there, you can often just type:
  <name>

>h2 Entry Point
Use:
  void main() { ... }
or:
  int main() { ... return 0; }

>h2 Command-Line Arguments
CupidC programs read args via:
  char *args = get_args();

Example:
  void main() {
    char *args = get_args();
    if (args && args[0]) {
      print("args: ");
      println(args);
    } else {
      println("no args");
    }
  }

>h2 Hello Example
void main() {
  println("Hello from CupidC");
  print("cwd: ");
  println(get_cwd());
}

Save as /home/bin/hello.cc, then run:
  hello

>h2 Language Features (Current)
Supported core features include:
- int, char, void, pointers
- structs (including field access)
- arrays
- if / else
- ternary conditional operator (cond ? a : b)
- while / for / do-while
- switch / case / default
- break / continue / return
- function definitions and calls
- typedef and enum support
- basic inline asm blocks
- arithmetic and logical operators

Known practical constraints:
- It is not full GCC C.
- Keep code simple and direct.
- Preprocessor/macros are not a normal workflow.
- One-file program style is the easiest path.

>h2 Preprocessor Update (2026-02-17)
CupidC now supports:
- #pragma once

Use this at the top of reusable include-style .cc files (for example
bin/ctxt.cc) to prevent duplicate-definition errors when a file is
included multiple times.

>h2 Useful Bindings (Partial List)
Console:
  print, println, putchar, print_int, print_hex, clear_screen

Memory:
  kmalloc, kfree, memstats, heap_check_integrity, detect_memory_leaks

VFS:
  vfs_open, vfs_read, vfs_write, vfs_seek, vfs_close
  vfs_stat, vfs_readdir, vfs_mkdir, vfs_unlink, vfs_rename
  vfs_read_all, vfs_write_all, vfs_read_text, vfs_write_text, vfs_copy_file

Clipboard:
  clipboard_set, clipboard_get, clipboard_len

Shell/process:
  get_cwd, set_cwd, resolve_path, get_history_count, get_history_entry
  process_list, process_kill, spawn_test, yield, exit, exec
  get_args

Time/system:
  uptime_ms, get_cpu_mhz, timer_get_frequency
  rtc_hour/minute/second/day/month/year/weekday, rtc_epoch
  date_full_string, time_string, etc.

Debug:
  dump_stack_trace, dump_registers, peek_byte, print_hex_byte
  set_log_level, get_log_level_name, print_log_buffer

Disk/cache:
  blockcache_sync, blockcache_stats

GUI/graphics:
  Large gfx2d and desktop UI binding set is available in GUI mode.

Notepad integration (CupidC app handoff):
  notepad_get_open_path(out_path, out_save_path)
  (used by bin/notepad.cc to receive desktop/calendar launch paths)

Rendering backend note (2026-02-17):
- CupidOS now uses an internal SSE2 SIMD acceleration layer for hot paths.
- This speeds up framebuffer flip, clear, rect fill, and alpha blit loops.
- CupidC gfx2d APIs are unchanged; programs do not need source changes.

>h2 New Graphics/Desktop Bindings (2026-02-14)
Recently added for GUI app and desktop-oriented workflows:

- gfx2d_text_wrap(x, y, w, str, color, font)
  Draw wrapped text inside a fixed pixel width.

- gfx2d_surface_blit_scaled(handle, x, y, w, h)
  Draw an offscreen surface scaled to destination size.

- gfx2d_icon_draw_named(label, x, y, color)
  Draw a registered desktop icon by label name.

- gfx2d_glow_circle(cx, cy, radius, color, alpha)
  Draw radial glow accents (useful for hover/highlight FX).

- gfx2d_light_sweep(x, y, w, h, tick, color, alpha)
  Draw animated diagonal light sweep over a rectangular UI region.

- gfx2d_popup_menu(x, y, items, count)
  Show a modal context menu and return selected index.

- gfx2d_tooltip(x, y, text)
  Draw non-modal tooltip text near the cursor.

- gfx2d_message_dialog(message)
  Show modal message dialog (supports wrapped text and scrolling for long
  content).

Desktop app source metadata now also supports:
- //app: Simple Name
- //app: label="Name"; desc="Description"; icon=app; x=120; y=80;

This registers launchable desktop icons when /bin .cc files are scanned.

>h2 New Windowed App + Terminal Bindings (2026-02-17)
These were added for true windowed CupidC apps (for example the rewritten
BG Studio and terminal.cc window process):

Window lifecycle:
- gui_win_create(title, x, y, w, h) -> int window_id (or -1)
- gui_win_is_open(window_id) -> int
- gui_win_close(window_id)

Window content geometry:
- gui_win_content_x(window_id) -> int
- gui_win_content_y(window_id) -> int
- gui_win_content_w(window_id) -> int
- gui_win_content_h(window_id) -> int

Window input + present:
- gui_win_poll_key(window_id) -> packed key or -1
  packed format: (scancode << 8) | char
- gui_win_flip(window_id)
  note: flips only when that window is focused (prevents z-order fights)

Terminal/shell buffer surface:
- shell_buf_rows() / shell_buf_cols()
- shell_buf_char(row, col)
- shell_buf_color(row, col)
- shell_cursor_x() / shell_cursor_y()
- shell_send_key(scancode, ch)

Terminal rendering helpers:
- ansi_color(vga_idx) -> 24-bit RGB
- gfx2d_char(x, y, ch, color)
- gfx2d_char_scaled(x, y, ch, color, scale)
- gfx2d_text_simple(x, y, str, color)

Input helper added with windowed terminal controls:
- keyboard_ctrl_held() -> int

Desktop background control bindings used by BG Studio:
- desktop_bg_set_mode_anim(theme)
- desktop_bg_set_mode_solid(color)
- desktop_bg_set_mode_gradient(top, bottom)
- desktop_bg_set_mode_tiled_pattern(pattern, fg, bg)
- desktop_bg_set_mode_tiled_bmp(path)
- desktop_bg_set_mode_bmp(path)
- desktop_bg_get_mode()
- desktop_bg_get_solid_color()
- desktop_bg_get_anim_theme()
- desktop_bg_get_tiled_pattern()
- desktop_bg_get_tiled_use_bmp()

>h2 Fast Workflow
1) Create source:
   ed /home/bin/mycmd.cc

2) Run directly:
   mycmd

3) If needed, run with explicit compiler:
   cupidc /home/bin/mycmd.cc

4) Produce ELF artifact:
   ccc /home/bin/mycmd.cc -o /home/mycmd

5) Inspect generated instructions:
  cc -d /home/bin/mycmd.cc
  dis /home/mycmd

>h2 Error Handling Tips
- CupidC fails fast and reports line-oriented compiler errors.
- If behavior is odd, reduce code to a tiny repro and re-add features.
- Keep stack usage modest.
- Prefer kmalloc for large buffers.

>h2 When To Use CupidC Vs ELF C
Use CupidC when:
- You want fastest edit/run loop inside CupidOS shell.
- You want direct access to many kernel helper bindings.

Use ELF C (see 05ELFPROG.TXT) when:
- You want external GCC-based build flow.
- You want a stable syscall-table ABI style entrypoint.

